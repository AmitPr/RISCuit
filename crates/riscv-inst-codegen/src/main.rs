mod bitspec;
mod isa;
mod r#match;
mod opcode;

pub use {bitspec::*, isa::*, opcode::*, r#match::*};

use proc_macro2::TokenStream;
use quote::quote;
use syn::{Ident, LitInt};

use std::{collections::HashMap, io::Write, path::Path};

pub fn mask(width: usize, shift: usize) -> LitInt {
    let mask: u64 = (1 << width) - 1;
    let mask: u64 = mask << shift;
    let mask = format!("{:#b}", mask);

    LitInt::new(&mask, proc_macro2::Span::call_site())
}

const RISCV_OPERANDS: &str = include_str!("../riscv-meta/operands");
const RISCV_OPCODES: &str = include_str!("../riscv-meta/opcodes");

const PKG_DIR: &str = env!("CARGO_MANIFEST_DIR");

macro_rules! isa {
    (@ext F) => {
        RvExt::F(FExt::F)
    };
    (@ext D) => {
        RvExt::F(FExt::D)
    };
    (@ext Q) => {
        RvExt::F(FExt::Q)
    };
    (@ext $ext:ident) => {
        RvExt::$ext
    };
    ($base:ident, $($ext:ident),*) => {
        Isa::new(Base::$base, &[$(isa!(@ext $ext)),*])
    };

}

const ISAS_TO_GEN: &[Isa] = &[
    isa!(RV32,),
    isa!(RV32, M),
    isa!(RV32, M, C),
    isa!(RV32, M, A, C),
    isa!(RV32, M, A, S, C),
    isa!(RV32, M, A, S, F, C),
    isa!(RV32, M, A, S, D, C),
    isa!(RV32, M, A, S, Q, C),
    isa!(RV64,),
    isa!(RV64, M),
    isa!(RV64, M, C),
    isa!(RV64, M, A, C),
    isa!(RV64, M, A, S, C),
    isa!(RV64, M, A, S, F, C),
    isa!(RV64, M, A, S, D, C),
    isa!(RV64, M, A, S, Q, C),
];

fn main() {
    let codegen = codegen();

    let out_dir = Path::new(PKG_DIR).join("../riscv-inst/src/codegen/");
    std::fs::remove_dir_all(&out_dir).unwrap_or_default();
    std::fs::create_dir_all(&out_dir).unwrap();

    let preamble = format!(
        "//! Autogenerated by {}\n//! DO NOT EDIT\n\n",
        env!("CARGO_PKG_NAME")
    );
    for (isa, code) in &codegen {
        let out_file = out_dir.join(format!("{}.rs", isa));
        let mut file = std::fs::File::create(&out_file).unwrap();
        file.write_all(preamble.as_bytes()).unwrap();
        file.write_all(code.as_bytes()).unwrap();
    }

    let mod_file = out_dir.join("mod.rs");
    let mut mod_file = std::fs::File::create(&mod_file).unwrap();
    let mod_code = {
        let mods = codegen
            .iter()
            .map(|(isa, _)| isa)
            // .chain(base_gen.iter().map(|(isa, _)| isa))
            .map(|isa| {
                let mod_name = Ident::new(isa, proc_macro2::Span::call_site());
                quote! {
                    pub mod #mod_name;
                }
            });

        let gen = syn::parse_quote! {
            #![allow(unused_parens, clippy::unnecessary_cast, clippy::write_literal, clippy::identity_op)]
            pub(crate) use crate::{Reg, FReg};

            #(#mods)*
        };

        prettyplease::unparse(&gen)
    };
    mod_file.write_all(preamble.as_bytes()).unwrap();
    mod_file.write_all(mod_code.as_bytes()).unwrap();

    // Run cargo fmt in the riscv-inst directory
    let wd = Path::new(PKG_DIR).join("../riscv-inst");
    std::process::Command::new("cargo")
        .args(["fmt"])
        .current_dir(&wd)
        .status()
        .unwrap();

    // Run cargo clippy --fix --allow-dirty in the riscv-inst directory (SLOW)
    // Currently just #[allow]-ing the lints that are triggered
    // std::process::Command::new("cargo")
    //     .args(["clippy", "--fix", "--allow-dirty"])
    //     .current_dir(wd)
    //     .status()
    //     .unwrap();
}

fn preprocess(spec: &str) -> Vec<Vec<String>> {
    spec.lines()
        .filter(|line| !line.starts_with('#'))
        .map(|line| line.split_whitespace().map(String::from).collect())
        .filter(|line: &Vec<String>| !line.is_empty())
        .collect::<Vec<_>>()
}

fn codegen() -> Vec<(String, String)> {
    let operands = preprocess(RISCV_OPERANDS);
    let opcodes = preprocess(RISCV_OPCODES)
        .into_iter()
        .map(Opcode::parse)
        .collect::<Vec<_>>();

    let accessors: HashMap<String, (Ident, TokenStream)> = operands
        .iter()
        .map(|operand| {
            let operand_name = &operand[0];
            let operand_accessor_fn = generate_operand_accessor_fn(operand);
            let fn_ident = Ident::new(&operand[3], proc_macro2::Span::call_site());

            (operand_name.clone(), (fn_ident, operand_accessor_fn))
        })
        .collect();

    let gen_isas = group_by_isa(opcodes);

    gen_isas
        .into_iter()
        .map(|(isa, opcodes)| {
            let isa_enum = generate_isa_enum(isa, opcodes, &accessors);

            let gen = syn::parse_quote! {
                #[allow(unused_imports)]
                use super::{Reg, FReg};

                #isa_enum
            };

            (isa.to_string(), prettyplease::unparse(&gen))
        })
        .collect()
}

fn generate_operand_accessor_fn(operand: &[String]) -> TokenStream {
    let fn_ident = Ident::new(&operand[3], proc_macro2::Span::call_site());
    let operand_type = match operand[2].as_str() {
        "arg" => quote!(u32),    // Argument
        "creg" => quote!(Reg),   // Compressed Register (= Reg+8)
        "ireg" => quote!(Reg),   // Integer Register
        "freg" => quote!(FReg),  // FP Register
        "offset" => quote!(i32), // Signed Offset
        "simm" => quote!(i32),   // Sign Extended Immediate
        "uimm" => quote!(u32),   // Zero Extended Immediate
        _ => panic!("Unknown operand type: {}", operand[2]),
    };
    // Signal to bitspec to +8 this register
    let spec_ty = if operand[2] == "creg" {
        quote!(CReg)
    } else {
        operand_type.clone()
    };
    let accessor = serialize_bitspecs(quote! { (self.0 as u32) }, spec_ty, &operand[1]);

    // TODO: Sign extension
    quote! {
        #[inline(always)]
        pub const fn #fn_ident(&self) -> #operand_type {
            #accessor
        }
    }
}

fn group_by_isa(opcodes: Vec<Opcode>) -> HashMap<Isa, Vec<Opcode>> {
    // First, group by extension
    let mut by_ext: HashMap<String, Vec<Opcode>> = HashMap::new();
    for opcode in opcodes {
        for isa in &opcode.isas {
            by_ext.entry(isa.clone()).or_default().push(opcode.clone());
        }
    }

    // Then combine extensions into each ISA.
    let mut gen_isas: HashMap<Isa, Vec<Opcode>> = HashMap::new();
    for isa in ISAS_TO_GEN {
        for (group, ops) in by_ext.iter() {
            if isa.contains(group) {
                gen_isas.entry(*isa).or_default().extend(ops.clone());
            }
        }
    }

    gen_isas
}

fn generate_isa_enum(
    isa: Isa,
    opcodes: Vec<Opcode>,
    accessors: &HashMap<String, (Ident, TokenStream)>,
) -> TokenStream {
    let isa_ident = isa.ident();

    let variants = opcodes.iter().map(Opcode::as_variant).collect::<Vec<_>>();
    let names = opcodes.iter().map(Opcode::name_ident).collect::<Vec<_>>();

    let opcode_structs = opcodes
        .iter()
        .map(|opcode| opcode.codegen_struct(accessors))
        .collect::<Vec<_>>();

    let impls = quote! {
            impl std::fmt::Debug for #isa_ident {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        #( #isa_ident::#names(inst) => write!(f, "{inst:?}") ),*
                    }
                }
            }

            impl std::fmt::Display for #isa_ident {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        #( #isa_ident::#names(inst) => write!(f, "{inst}") ),*
                    }
                }
            }

    };

    let decode_fn = generate_opcode_parser(opcodes, isa);

    quote! {
        #[derive(Clone, Copy, PartialEq, Eq)]
        #[repr(u8)]
        pub enum #isa_ident {
            #(#variants),*
        }

        impl #isa_ident {
            #decode_fn
        }

        #(#opcode_structs)*

        #impls
    }
}
