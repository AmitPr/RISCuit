mod bitspec;
mod r#match;

use std::{collections::HashMap, io::Write, path::Path};

use proc_macro2::TokenStream;
use quote::quote;

const RISCV_OPERANDS: &str = include_str!("../riscv-meta/operands");
const RISCV_OPCODES: &str = include_str!("../riscv-meta/opcodes");

const PKG_DIR: &str = env!("CARGO_MANIFEST_DIR");

fn main() {
    let codegen = codegen();

    let out_dir = Path::new(PKG_DIR).join("../riscv-inst/src/codegen/");
    std::fs::remove_dir_all(&out_dir).unwrap_or_default();
    std::fs::create_dir_all(&out_dir).unwrap();

    let preamble = format!(
        "//! Autogenerated by {}\n//! DO NOT EDIT\n\n",
        env!("CARGO_PKG_NAME")
    );
    for (isa, code) in &codegen {
        let out_file = out_dir.join(format!("{}.rs", isa));
        let mut file = std::fs::File::create(&out_file).unwrap();
        file.write_all(preamble.as_bytes()).unwrap();
        file.write_all(code.as_bytes()).unwrap();
    }

    let mod_file = out_dir.join("mod.rs");
    let mut mod_file = std::fs::File::create(&mod_file).unwrap();
    let mod_code = {
        let mods = codegen.iter().map(|(isa, _)| {
            let mod_name = syn::Ident::new(isa, proc_macro2::Span::call_site());
            quote! {
                pub mod #mod_name;
            }
        });

        let gen = syn::parse_quote! {
            pub use crate::{Reg, FReg};

            #(#mods)*
        };

        prettyplease::unparse(&gen)
    };
    mod_file.write_all(preamble.as_bytes()).unwrap();
    mod_file.write_all(mod_code.as_bytes()).unwrap();

    // Run cargo fmt in the riscv-inst directory
    let wd = Path::new(PKG_DIR).join("../riscv-inst");
    std::process::Command::new("cargo")
        .args(["fmt"])
        .current_dir(&wd)
        .status()
        .unwrap();

    // Run cargo clippy --fix --allow-dirty in the riscv-inst directory
    std::process::Command::new("cargo")
        .args(["clippy", "--fix", "--allow-dirty"])
        .current_dir(wd)
        .status()
        .unwrap();
}

fn preprocess(spec: &str) -> Vec<Vec<String>> {
    spec.lines()
        .filter(|line| !line.starts_with('#'))
        .map(|line| {
            line.split_whitespace()
                .map(|s| s.to_string())
                .collect::<Vec<_>>()
        })
        .filter(|line| !line.is_empty())
        .collect::<Vec<_>>()
}

fn codegen() -> Vec<(String, String)> {
    let operands = preprocess(RISCV_OPERANDS);
    let opcodes = preprocess(RISCV_OPCODES);

    r#match::generate_opcode_parser(opcodes.clone());

    let accessors: HashMap<String, TokenStream> = operands
        .iter()
        .map(|operand| {
            let operand_name = &operand[0];
            let operand_accessor_fn = generate_operand_accessor_fn(operand);

            (operand_name.clone(), operand_accessor_fn)
        })
        .collect();

    let by_isa = group_by_isa(opcodes);

    by_isa
        .into_iter()
        .map(|(isa, opcodes)| {
            let isa_enum = generate_isa_enum(isa.clone(), opcodes, &accessors);

            let gen = syn::parse_quote! {
                #[allow(unused_imports)]
                use super::{Reg, FReg};

                #isa_enum
            };

            (isa, prettyplease::unparse(&gen))
        })
        .collect::<Vec<_>>()
}

fn generate_operand_accessor_fn(operand: &[String]) -> TokenStream {
    let fn_ident = syn::Ident::new(&operand[3], proc_macro2::Span::call_site());
    let operand_type = match operand[2].as_str() {
        // Argument
        "arg" => quote!(u32),
        // Compressed Register (is just Reg with +8)
        "creg" => quote!(Reg),
        // Integer Register
        "ireg" => quote!(Reg),
        // Floating Point Register
        "freg" => quote!(FReg),
        // Signed Offset
        "offset" => quote!(i32),
        // Sign Extended Immediate
        "simm" => quote!(i32),
        // Zero Extended Immediate
        "uimm" => quote!(u32),
        _ => panic!("Unknown operand type: {}", operand[2]),
    };
    let accessor = bitspec::serialize_bitspecs(
        quote! { (self.0 as u32) },
        operand_type.clone(),
        &operand[1],
    );

    // TODO: Sign extension
    quote! {
        #[inline]
        pub const fn #fn_ident(&self) -> #operand_type {
            #accessor
        }
    }
}

fn group_by_isa(opcodes: Vec<Vec<String>>) -> HashMap<String, Vec<Vec<String>>> {
    let mut isas = HashMap::new();
    for opcode in opcodes {
        for arg in opcode.iter().rev() {
            if arg.starts_with("rv") {
                let isa = isas.entry(arg.clone()).or_insert_with(Vec::new);
                isa.push(opcode.clone());
            } else {
                break;
            }
        }
    }

    isas
}

fn opcode_ident(opcode: &str) -> syn::Ident {
    // capitalize first letter of each word
    let opcode = opcode
        .split('.')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(c) => c.to_uppercase().chain(chars).collect(),
            }
        })
        .collect::<String>();

    syn::Ident::new(&opcode, proc_macro2::Span::call_site())
}

fn opcode_operands(mut opcode: Vec<String>) -> Vec<String> {
    while let Some(arg) = opcode.pop() {
        if arg.starts_with("rv") {
            continue;
        }
        break;
    }

    opcode[1..]
        .iter()
        .filter(|&arg| arg.chars().next().map_or(false, |c| c.is_alphabetic()))
        .cloned()
        .collect()
}

fn generate_opcode_struct(
    opcode: Vec<String>,
    accessors: &HashMap<String, TokenStream>,
    rv_c: bool,
) -> TokenStream {
    let opcode_ident = opcode_ident(&opcode[0]);
    let operands = opcode_operands(opcode.clone());
    let operand_accessors = operands
        .iter()
        .map(|operand| {
            accessors.get(operand).unwrap_or_else(|| {
                panic!("Failed to find accessor for operand '{}'", operand);
            })
        })
        .collect::<Vec<_>>();
    let operand_inner_ty = if rv_c {
        quote! { pub u16 }
    } else {
        quote! { pub u32 }
    };

    quote! {
        pub struct #opcode_ident(#operand_inner_ty);

        impl #opcode_ident {
            #(#operand_accessors)*
        }
    }
}

fn isa_ident(isa: &str) -> syn::Ident {
    // capitalize first letter
    let isa = isa
        .chars()
        .next()
        .unwrap()
        .to_uppercase()
        .chain(isa.chars().skip(1))
        .collect::<String>();
    syn::Ident::new(&isa, proc_macro2::Span::call_site())
}

fn generate_isa_enum(
    isa: String,
    opcodes: Vec<Vec<String>>,
    accessors: &HashMap<String, TokenStream>,
) -> TokenStream {
    let rv_c = isa.contains("c");
    let isa_ident = isa_ident(&isa);

    let variants = opcodes
        .iter()
        .map(|opcode| {
            let opcode = opcode_ident(&opcode[0]);
            quote! {
                #opcode(#opcode),
            }
        })
        .collect::<Vec<_>>();

    let opcode_structs = opcodes
        .iter()
        .map(|opcode| generate_opcode_struct(opcode.clone(), accessors, rv_c))
        .collect::<Vec<_>>();
    quote! {
        pub enum #isa_ident {
            #(#variants)*
        }

        #(#opcode_structs)*
    }
}
