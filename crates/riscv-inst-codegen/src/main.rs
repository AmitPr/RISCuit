mod bitspec;
mod r#match;
mod opcode;

use std::{collections::HashMap, io::Write, path::Path};

use opcode::Opcode;
use proc_macro2::TokenStream;
use quote::quote;

const RISCV_OPERANDS: &str = include_str!("../riscv-meta/operands");
const RISCV_OPCODES: &str = include_str!("../riscv-meta/opcodes");

const PKG_DIR: &str = env!("CARGO_MANIFEST_DIR");

fn main() {
    let codegen = codegen();

    let out_dir = Path::new(PKG_DIR).join("../riscv-inst/src/codegen/");
    std::fs::remove_dir_all(&out_dir).unwrap_or_default();
    std::fs::create_dir_all(&out_dir).unwrap();

    let preamble = format!(
        "//! Autogenerated by {}\n//! DO NOT EDIT\n\n",
        env!("CARGO_PKG_NAME")
    );
    for (isa, code) in &codegen {
        let out_file = out_dir.join(format!("{}.rs", isa));
        let mut file = std::fs::File::create(&out_file).unwrap();
        file.write_all(preamble.as_bytes()).unwrap();
        file.write_all(code.as_bytes()).unwrap();
    }

    let base_gen = codegen_base_isas(codegen.iter().map(|(isa, _)| isa.clone()).collect());
    for (isa, code) in &base_gen {
        let out_file = out_dir.join(format!("{}.rs", isa));
        let mut file = std::fs::File::create(&out_file).unwrap();
        file.write_all(preamble.as_bytes()).unwrap();
        file.write_all(code.as_bytes()).unwrap();
    }

    let mod_file = out_dir.join("mod.rs");
    let mut mod_file = std::fs::File::create(&mod_file).unwrap();
    let mod_code = {
        let mods = codegen
            .iter()
            .map(|(isa, _)| isa)
            .chain(base_gen.iter().map(|(isa, _)| isa))
            .map(|isa| {
                let mod_name = syn::Ident::new(isa, proc_macro2::Span::call_site());
                quote! {
                    pub mod #mod_name;
                }
            });

        let gen = syn::parse_quote! {
            pub use crate::{Reg, FReg};

            #(#mods)*
        };

        prettyplease::unparse(&gen)
    };
    mod_file.write_all(preamble.as_bytes()).unwrap();
    mod_file.write_all(mod_code.as_bytes()).unwrap();

    // Run cargo fmt in the riscv-inst directory
    let wd = Path::new(PKG_DIR).join("../riscv-inst");
    std::process::Command::new("cargo")
        .args(["fmt"])
        .current_dir(&wd)
        .status()
        .unwrap();

    // Run cargo clippy --fix --allow-dirty in the riscv-inst directory
    std::process::Command::new("cargo")
        .args(["clippy", "--fix", "--allow-dirty"])
        .current_dir(wd)
        .status()
        .unwrap();
}

fn preprocess(spec: &str) -> Vec<Vec<String>> {
    spec.lines()
        .filter(|line| !line.starts_with('#'))
        .map(|line| {
            line.split_whitespace()
                .map(|s| s.to_string())
                .collect::<Vec<_>>()
        })
        .filter(|line| !line.is_empty())
        .collect::<Vec<_>>()
}

fn codegen() -> Vec<(String, String)> {
    let operands = preprocess(RISCV_OPERANDS);
    let opcodes = preprocess(RISCV_OPCODES)
        .into_iter()
        .map(Opcode::parse)
        .collect::<Vec<_>>();

    let accessors: HashMap<String, TokenStream> = operands
        .iter()
        .map(|operand| {
            let operand_name = &operand[0];
            let operand_accessor_fn = generate_operand_accessor_fn(operand);

            (operand_name.clone(), operand_accessor_fn)
        })
        .collect();

    let by_isa = group_by_isa(opcodes);

    by_isa
        .into_iter()
        .map(|(isa, opcodes)| {
            let isa_enum = generate_isa_enum(isa.clone(), opcodes, &accessors);

            let gen = syn::parse_quote! {
                #[allow(unused_imports)]
                use super::{Reg, FReg};

                #isa_enum
            };

            (isa, prettyplease::unparse(&gen))
        })
        .collect::<Vec<_>>()
}

fn codegen_base_isas(isas: Vec<String>) -> Vec<(String, String)> {
    let opcodes = preprocess(RISCV_OPCODES)
        .into_iter()
        .map(Opcode::parse)
        .collect::<Vec<_>>();

    let mut results = Vec::new();
    for base in ["rv32", "rv64"] {
        let relevant_isas = isas.iter().filter(|isa| isa.contains(base));
        let filtered = opcodes
            .clone()
            .into_iter()
            .filter(|opcode| opcode.isas.iter().any(|isa| isa.contains(base)))
            .collect::<Vec<_>>();
        let decode_fn = r#match::generate_opcode_parser(filtered, base.to_string());

        let base_ident = isa_ident(base);
        let variants = relevant_isas.clone().map(|isa| {
            let isa_ident = isa_ident(isa);
            quote! {
                #isa_ident(#isa_ident),
            }
        });

        let imports = relevant_isas
            .clone()
            .map(|isa| {
                let isa_mod = syn::Ident::new(isa, proc_macro2::Span::call_site());
                quote! {
                    pub use super::#isa_mod::*;
                }
            })
            .collect::<Vec<_>>();

        let gen = syn::parse_quote! {
            #( #imports )*

            pub enum #base_ident {
                #(#variants)*
            }

            impl #base_ident {
                #decode_fn
            }
        };

        results.push((base.to_string(), prettyplease::unparse(&gen)));
    }

    results
}

fn generate_operand_accessor_fn(operand: &[String]) -> TokenStream {
    let fn_ident = syn::Ident::new(&operand[3], proc_macro2::Span::call_site());
    let operand_type = match operand[2].as_str() {
        // Argument
        "arg" => quote!(u32),
        // Compressed Register (is just Reg with +8)
        "creg" => quote!(Reg),
        // Integer Register
        "ireg" => quote!(Reg),
        // Floating Point Register
        "freg" => quote!(FReg),
        // Signed Offset
        "offset" => quote!(i32),
        // Sign Extended Immediate
        "simm" => quote!(i32),
        // Zero Extended Immediate
        "uimm" => quote!(u32),
        _ => panic!("Unknown operand type: {}", operand[2]),
    };
    let accessor = bitspec::serialize_bitspecs(
        quote! { (self.0 as u32) },
        operand_type.clone(),
        &operand[1],
    );

    // TODO: Sign extension
    quote! {
        #[inline]
        pub const fn #fn_ident(&self) -> #operand_type {
            #accessor
        }
    }
}

fn group_by_isa(opcodes: Vec<Opcode>) -> HashMap<String, Vec<Opcode>> {
    let mut isas = HashMap::new();
    for opcode in opcodes {
        for isa in &opcode.isas {
            let isa = isas.entry(isa.clone()).or_insert_with(Vec::new);
            isa.push(opcode.clone());
        }
    }

    isas
}

pub(crate) fn isa_ident(isa: &str) -> syn::Ident {
    // capitalize first letter
    let isa = isa
        .chars()
        .next()
        .unwrap()
        .to_uppercase()
        .chain(isa.chars().skip(1))
        .collect::<String>();
    syn::Ident::new(&isa, proc_macro2::Span::call_site())
}

fn generate_isa_enum(
    isa: String,
    opcodes: Vec<Opcode>,
    accessors: &HashMap<String, TokenStream>,
) -> TokenStream {
    let rv_c = isa.contains("c");
    let isa_ident = isa_ident(&isa);

    let variants = opcodes
        .iter()
        .map(|opcode| {
            let ident = opcode.name_ident();
            quote! {
                #ident(#ident),
            }
        })
        .collect::<Vec<_>>();

    let opcode_structs = opcodes
        .iter()
        .map(|opcode| opcode.codegen_struct(accessors, rv_c))
        .collect::<Vec<_>>();
    quote! {
        pub enum #isa_ident {
            #(#variants)*
        }

        #(#opcode_structs)*
    }
}
